#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t
#+PROPERTY: header-args:emacs-lisp    :tangle ~/.config/emacs/init.el :results silent :mkdirp t
#+STARTUP: content
* Introduction

This is my Emacs configuration. Is a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document:
prose interspersed with code blocks. I edit this file, and /tangle/ it
into [[file:../../../../../Users/stig/.config/emacs/init.el][init.el]] (and other config files) by hitting =C-c C-v C-t=.

I install Emacs itself using Homebrew, along with other tools
(~ripgrep~, etc) using a [[file:Brewfile][Brewfile]].

* Early Init
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/.config/emacs/early-init.el :results silent :mkdirp t
:END:

Emacs loads =early-init.el= before loading GUI components. That makes
it a great place to turn off the mouse interface, to avoid momentary
display during launch. I also disable the splash screen, the audible
bell, and the ~package.el~ subsystem.

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

(setq inhibit-startup-screen t
      visible-bell t
      package-enable-at-startup nil)
#+end_src

* Use lexical bindings
Using lexical bindings speeds up loading config, if I understand
correctly.
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src
* Where and who am I?

I use one computer for work, and another for personal stuff. I don't
have vastly different configs, but I do set some variables
differently. So here we set a variable to help us determine what
context we're in later.

#+begin_src emacs-lisp
(setq sb/home? (string-match "margil" (system-name)))
#+end_src

Set up my name, email address, and login. I use the email in my
Notmuch config below, and some of these show up in Org mode's export
metadata.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Stig Brautaset"
      user-mail-address (if sb/home? "stig@brautaset.org" "stig@circleci.com")
      user-login-name "stig")
#+END_SRC

* Bootstrap config

I'm using =straight.el= to install packages, and =use-package= to
configure them. Because of that, we need to bootstrap them near the
start of the config.

** Bootstrap =straight.el=

One of the things I like about straight is that it makes it easier to
make local changes to modules, and contribute these back to modules I
use.

I don't feel the need to specify ~:straigth t~ in every ~use-package~
stanza, so I specify that to be the default.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(setq straight-use-package-by-default t)
#+end_src

** Install =use-package= and friends

I appreciate that =use-package= makes it easier to write lazy loading
configuration. I also like that its manual documents all the options
for configuration in one place.

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(straight-use-package 'bind-key)
(straight-use-package 'diminish)

(eval-when-compile
  (require 'use-package))
(require 'diminish)
(require 'bind-key)
#+end_src

* Better Defaults

** Auto-revert mode

When open files change on disk, I want to revert the corrersponding
buffer. This is useful when checking out a different branch in Magit,
and because I use Syncthing to share my Org "Exo Brain" between two
computers.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

** Configure Control/Meta/super/hyper keys

#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'meta
      mac-control-modifier 'control
      mac-function-modifier 'hyper
      mac-option-modifier 'super)
#+END_SRC

** Confirm kill emacs

The default keybinding for this is close to =M-q= which I use for
reflowing text.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

** Display line numbers

Displaying line numbers is incredibly useful when remotely pairing
with other people.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode)))
#+end_src

** Don't require two spaces to end a sentence

Having this enabled makes it harder to collaborate with others, and
move sentences around in texts I haven't written.

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

** End all files in a newline

All files should end in a newline. Insert one if there isn't one already.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

** Ensure we don't use unencrypted auth sources

This could take the form of e.g. saving auth info to =~/.authinfo=, or
=~/.netrc= rather than =~/.authinfo.gpg=, for example.

#+begin_src emacs-lisp
(setq auth-sources (quote ("~/.authinfo.gpg")))
#+end_src

** Eshell

Eshell is great, and its Tramp integration allows me to open remote
files in local Emacs seamlessly with the =find-file= command. (Which I
have aliased to =ff=.) Eshell also makes sure that my shell behaves
the same, and has the same config, whether I am on a local machine or
a remote one. It is my primary shell nowadays.

#+BEGIN_SRC emacs-lisp
(bind-key "C-c s" 'eshell)
#+END_SRC

** GnuPG

Emacs will open =.gpg= files transparently, but I need to install gnupg
& pinentry for that to work.

#+begin_src emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+end_src

** Make 'y' and 'n' satisfy prompts

Answering just 'y' or 'n' will do, rather than having to spell out "yes"
or "no".

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Make Customize settings transient
Store settings applied via [[info:emacs#Easy Customization][info:emacs#Easy Customization]] in a
temporary file, so they don't persist across restarts of Emacs. I
prefer to code my configuration. Credit to Robin Schroer for this
trick.

#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file ""))
#+END_SRC

** Prefer Ibuffer over Buffer Menu
One of the key features for me is ibuffer's ability to filter by major mode.
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src
** Prefer YMD for dates in Diary / Calendar

#+BEGIN_SRC emacs-lisp
(setq calendar-date-style 'iso)
#+END_SRC

** Spell check comments & strings in code
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'flyspell-prog-mode)
#+end_src

** Save minibuffer history

This allows us to "tap up" in the minibuffer to recall previous items,
even from a previous session.

#+BEGIN_SRC emacs-lisp
(savehist-mode 1)
#+END_SRC

** Save my place in each file

It's nice if Emacs knows where I was last time I opened a file.

#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC

** Show Matching parens

Put the cursor on any of =()[]{}= and Emacs shows the matching
closing/opening one.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

** Simple HTML Renderer (HTML Email)

I use shr for reading HTML mail. I normally use a fullscreen window,
but I don't like reading HTML mails with lines running all the way
across. Thus I prefer linebreaks roughly every 80 characters.

#+begin_src emacs-lisp
(setq shr-width 80)
#+end_src

** Store backup and auto-save files in a separate folder

I don't like backup and auto-save files all over my disk. This places
them in a separate directory.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory))))

(setq auto-save-list-file-prefix (expand-file-name "auto-save" user-emacs-directory)
      auto-save-file-name-transforms `((".*" ,auto-save-list-file-prefix)))
#+END_SRC

** Support recursive minibuffers

I like to be able to use my kill-ring in the minibuffer.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src
** Transparently open compressed files

I *do* like it when Emacs transparently opens compressed files. It gives
me the warm fuzzies.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC

** Upcase-dwim and dowcase-dwim

Acts like ~upcase-word~ with no region selected, and ~upcase-region~
when one is.

#+begin_src emacs-lisp
(bind-key "M-u" #'upcase-dwim)
(bind-key "M-l" #'downcase-dwim)
#+end_src
** UTF-8: everywhere, always

Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** View Mode
Navigate read-only buffers up and down with space and backspace.

#+begin_src emacs-lisp
(setq view-read-only t)
#+end_src
** Visual line mode / word wrapping

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'visual-line-mode)
#+END_SRC

* Appearance
** Default Theme

Right now I'm experimenting with "Material Light" theme. I like that
it's got a light background, and muted colours.

#+begin_src emacs-lisp
(use-package material-theme
  :config
  (load-theme 'material-light t))
#+end_src

** Font size

I like big fonts, and I cannot lie.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :height 150)
#+END_SRC

** Font

I install this font with Homebrew, from my [[file:Brewfile][Brewfile]].
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "Jetbrains Mono")
#+END_SRC

* Custom Functions
** Blogging
I create blog entries in a directory under =~/blog= and link to them
from the main index page. It has so far been a manual job, but I have
finally managed to create a function to automate it a bit.

*** Helper function to get a value from Org keyword element

#+begin_src emacs-lisp
(defun sb/org-kw-get (key)
  "Return a lambda that takes an Org keyword element and returns
its :value property if its :key property matches `key'."
  `(lambda (kw)
     (if (equal ,key (org-element-property :key kw))
         (org-element-property :value kw))))
#+end_src

*** Create blog post index entry

#+BEGIN_SRC emacs-lisp
(defun sb/blog-post-index-entry ()
  "Call in a blog post to get an entry suitable for linking to this
post from the index page."
  (interactive)
  (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
         (tree (org-element-parse-buffer))
         (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
         (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY"))))
    (with-temp-buffer
      (org-mode)
      (org-insert-heading)
      ;; Would have loved to use `org-insert-link' here but
      ;; I can't stop it from presenting a prompt.
      (insert "[[file:" path "][" title "]]\n"
              "#+include: " path "::abstract :only-contents t")
      ;; Need to go back to the first line to set tags, as
      ;; org-set-tags assumes point is on a headline.
      (goto-char (point-min))
      (org-set-tags categories)
      ;; Return the contents temporary buffer as a string *without properties*
      (copy-region-as-kill
       (point-min) (point-max)))))
#+END_SRC

*** Create RSS entry

Creating an entry in the RSS feed is another manual step. This way I
can "soft publish" and publish to RSS separately from the index page.

#+begin_src emacs-lisp
(defun sb/blog-post-rss-entry ()
  "Call in a blog post to get an entry suitable for linking to this
post from the index page."
  (interactive)
  (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
         (tree (org-element-parse-buffer))
         (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
         (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY"))))
    (with-temp-buffer
      (org-mode)
      (org-insert-heading)
      (insert title "\n"
	      "#+include: " path)
      (org-set-property "RSS_PERMALINK"
                        (format "%s.html"
                                (file-name-sans-extension path)))
      (copy-region-as-kill
       (point-min) (point-max)))))
#+end_src

*** Find drafts

#+begin_src emacs-lisp
(defun sb/find-drafts ()
  "Find org files in `~/blog/articles' not already linked from
              `~/blog/index.org'."
  (interactive)
  (let* ((prefix (expand-file-name "~/blog/"))
         (posts
          (directory-files-recursively
           (concat prefix "articles") ".org"))
         (index-contents (get-string-from-file (concat prefix "index.org")))
         (drafts (cl-remove-if (lambda (needle)
                                 (string-match
                                  (string-remove-prefix prefix needle)
                                  index-contents))
                               posts))
         (buffer-name "*blog drafts*"))
    (if drafts
        (progn
          (with-current-buffer (get-buffer-create buffer-name)
            (erase-buffer)
            (org-mode)
            (insert
             (mapconcat
              (lambda (entry)
                (format "- file:%s" entry))
              drafts
              "\n"))
            (buffer-string))
          (unless (get-buffer-window buffer-name t)
            (pop-to-buffer buffer-name nil t))
          (shrink-window-if-larger-than-buffer
           (get-buffer-window buffer-name)))
      (message "No drafts could be found!"))))
#+end_src

*** Blog server

While noodling around with my blog locally I publish to =~/blog=
and use a simple Python server to host it.

#+begin_src emacs-lisp
(defun sb/blog-server ()
  (interactive)
  (start-process "Blog Server" "*blog server*"
                 "python3"
                 "-m" "http.server"
                 "--directory" (expand-file-name "~/blog/"))
  (message "Blog Server started"))
#+end_src

** Delete buffer and file it is visiting

Copied from [[https://github.com/sulami/dotfiles/blob/master/emacs/.emacs/README.org#delete-buffer-file][sulami]]'s config.

#+begin_src emacs-lisp
(defun sb/delete-file-and-buffer ()
  "Deletes a buffer and the file it's visiting."
  (interactive)
  (when-let* ((file-name (buffer-file-name))
              (really (yes-or-no-p (format "Delete %s? "
                                           file-name))))
    (delete-file file-name)
    (kill-buffer)))
#+end_src

** Ediff: Automatically Unfold Org files

This snippet makes sure that Org buffers don't start folded, as
ediff is rather useless in that case. (Credit: Oleh Krehel on
emacs-orgmode mailing list.)

#+BEGIN_SRC emacs-lisp
(defun sb/ediff-prepare-buffer ()
  (when (memq major-mode '(org-mode emacs-lisp-mode))
    (outline-show-all)))

(add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
#+END_SRC

** Ediff: Picking /both/ sides in a conflict

If both branches add an entry to a list I may want to pick *both*
sides. This adds =d= as a shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) I can use
=~= to swap the A and B buffers, which lets me choose A then B, /or/ B
then A.

#+BEGIN_SRC emacs-lisp
(defun sb/ediff-copy-both-to-C ()
  (interactive)
  (ediff-copy-diff ediff-current-difference nil 'C nil
                   (concat
                    (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                    (ediff-get-region-contents
                     ediff-current-difference 'B
                     ediff-control-buffer))))

(defun sb/add-d-to-ediff-mode-map ()
  (define-key ediff-mode-map "d" 'sb/ediff-copy-both-to-C))

(add-hook 'ediff-keymap-setup-hook 'sb/add-d-to-ediff-mode-map)
#+END_SRC

** Hydra Theme Switching

Switch themes with Hydra! This loads all available themes and
presents a menu to let you switch between them. The theme switcher
is bound to =C-c w t=.

The switcher is, regretfully, not automatically updated when
installing new themes from the package selector menu, so you need to
evaluate this block again manually.

#+BEGIN_SRC emacs-lisp
(setq sb/hydra-selectors
      "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

(defun sb/load-theme-heads (themes)
  (cl-map 'list
          (lambda (a b)
            (list (char-to-string a)
                  `(sb/load-theme ',b)
                  (symbol-name b)))
          sb/hydra-selectors
          themes))

(defun sb/switch-theme ()
  (interactive)
  (call-interactively
   (eval `(defhydra sb/select-theme (:hint nil :color pink)
            "Select Theme"
            ,@(sb/load-theme-heads (custom-available-themes))
            ("DEL" (sb/disable-all-themes))
            ("RET" nil "done" :color blue)))))
#+END_SRC

** Load one theme at a time

For years I thought that theme switching in Emacs was broken---until
I read Greg Hendershott's [[http://www.greghendershott.com/2017/02/emacs-themes.html][emacs themes]] blog post. It turns out Emacs
supports /multiple themes being active at the same time/, which I'm
sure is convenient sometimes but becomes a right nuisance when
attempting to switch themes IMO. Add a utility function to disable
all currently enabled themes first.

#+BEGIN_SRC emacs-lisp
(defun sb/disable-all-themes ()
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(defun sb/load-theme (the-theme)
  "Enhance `load-theme' by first disabling enabled themes."
  (sb/disable-all-themes)
  (load-theme the-theme t))
#+END_SRC

** Toggle Window Split function

This function re-arranges horizontally-split windows to be
vertically-split, and vice versa. I found it on StackOverflow, once
upon a time but now can't find the link.

#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(define-key ctl-x-4-map "t" 'toggle-window-split)
#+END_SRC

** Unfill paragraphs and regions

The default binding for =M-q= fills a paragraph. Very good. But
sometimes I want to /unfill/, particularly when editing markdown that
is going to end up on GitHub. Otherwise the result has lots of hard
linebreaks. This happens every time I edit a PR description in Magit,
for example. [[Https://gist.github.com/heikkil/a3edf506046c84f6f508edbaf005810a][Credit]].

#+begin_src emacs-lisp
(defun endless/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command #'endless/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (if (eq major-mode 'org-mode)
        (call-interactively #' org-fill-paragraph)
      (call-interactively #'fill-paragraph))))

(global-set-key [remap fill-paragraph] #'endless/fill-or-unfill)
#+end_src

* Ace Window

This lets me rapidly switch to a different frame/window.  I use
this mainly when resolving conflicts in ediff merge, since I need
to swap between two frames there.

#+begin_src emacs-lisp
(use-package ace-window
  :bind (("C-S-s-<tab>" . ace-window) ; aka Meh-<tab>
	 ("M-`" . ace-window)))
#+end_src

* AsciiDoc
#+begin_src emacs-lisp
(use-package adoc-mode
  :mode ("\\.adoc\\'" . adoc-mode))
#+end_src
* Bug Reference Mode
Automatically create JIRA links for things that looks like them. For
this I've adapted snippets from Alex ter Weele and Robin Schroer.
#+begin_src emacs-lisp
;; `bug-reference-mode'
(defun sb/bug-reference-setup ()
  (setq bug-reference-bug-regexp
	(rx (group "")  ; deliberately empty capture group;
                        ; bug-reference assumes the first capture
                        ; group is something like "Bug-" that should
                        ; be thrown away.
            (group
             ;; <https://circleci.atlassian.net/projects?page=1&selectedCategory=all&selectedProjectType=all&sortKey=name&sortOrder=ASC>
             (or "ACE" "AE" "BACKPLANE" "CE" "CECIA" "CEOPS" "CIRCLE" "COGS" "COM"
		 "DATA" "DES" "DNAMEDIA" "DRC" "DS" "DSA" "DTP" "ENG" "ENGOPS" "EXP"
		 "INSIGHT" "IT" "JOM" "MAC" "MKTG" "OP" "PLATFORM" "POTS" "PROD" "RE"
		 "SEC" "SECOPS" "SERVER" "SRE" "TRAIN" "UXR" "WEB")
             "-"
             (any "1-9") (zero-or-more digit)))
	bug-reference-url-format "https://circleci.atlassian.net/browse/%s"))

(use-package bug-reference
  :straight nil
  :hook
  ((bug-reference-mode . sb/bug-reference-setup)
   (org-mode . bug-reference-mode)
   (clojure-mode . bug-reference-mode)))
#+end_src
* Clojure

Clojure is the main programming language I use at work.

** Clojure Mode

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :config
  (put-clojure-indent 'as-> ':defn)
  (put-clojure-indent 'run ':defn)
  (put-clojure-indent 'dosync ':defn)
  (put-clojure-indent 'speculate 1)
  (put-clojure-indent 'doseq ':defn)
  (put-clojure-indent 'wrap-with-timing ':defn)
  (put-clojure-indent 'wrap-with-per-call-timing ':defn))
#+END_SRC

** clj-kondo
Gives automatic linting for Clojure code.
#+BEGIN_SRC emacs-lisp
(use-package flycheck-clj-kondo)
#+END_SRC

** CIDER
This is the Clojure / ClojureScript REPL I use.
#+BEGIN_SRC emacs-lisp
(use-package cider
  :hook ((cider-mode . sb/unload-cider-jumps)
	 (cider-repl-mode . sb/unload-cider-jumps))
  :config
  (defun sb/unload-cider-jumps ()
    ;; I prefer lsp's jumps, so kindly don't steal them
    (define-key cider-mode-map (kbd "M-.") nil)
    (define-key cider-mode-map (kbd "M-,") nil))
  :custom
  (cider-prompt-for-symbol nil)
  (cider-redirect-server-output-to-repl nil)
  (cider-prefer-local-resources t)
  (cider-auto-track-ns-form-changes t)
  (cider-repl-pop-to-buffer-on-connect t)
  (cider-eldoc-display-context-dependent-info t)
  (cider-font-lock-dynamically '(macro core function var)))
#+END_SRC

** kaocha runner
For running kaucha test using CIDER
#+begin_src emacs-lisp
(use-package kaocha-runner
  :init
  (bind-keys :prefix-map ar-emacs-kaocha-prefix-map
             :prefix "C-c k"
             ("t" . kaocha-runner-run-test-at-point)
             ("r" . kaocha-runner-run-tests)
             ("a" . kaocha-runner-run-all-tests)
             ("w" . kaocha-runner-show-warnings)
             ("h" . kaocha-runner-hide-windows)))
#+end_src

** Refactoring support
#+begin_src emacs-lisp
(use-package clj-refactor
  :init
  (defun sb/clj-refactor-setup ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1) ; for adding require/use/import statements
    ;; This choice of keybinding leaves cider-macroexpand-1 unbound
    (cljr-add-keybindings-with-prefix "C-c C-m"))
  :hook (clojure-mode . sb/clj-refactor-setup))
#+end_src
* Company (COMplete ANYthing)
#+begin_src emacs-lisp
(use-package company
  :hook (after-init . global-company-mode))
#+end_src
* Diff Highlight

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode))
#+end_src
* Direnv
Set environment per directory. The plan is to use this with
Nix-direnv, to automatically set my PATH for a directory.

#+begin_src emacs-lisp
(use-package direnv
  :config
  (direnv-mode))
#+end_src
* Docker
#+begin_src emacs-lisp
(use-package docker)
#+end_src
* Dumb-jump

Trying this out again, now that it registers an xref backend:

#+begin_src emacs-lisp
(use-package dumb-jump
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src
* Edit Indirect
To edit code examples in a separate buffer from Markdown. (Similar to
code blocks in Org.)

#+begin_src emacs-lisp
(use-package edit-indirect)
#+end_src

* Elfeed
Elfeed is an Emacs (RSS & Atom) feed reader. ~org-elfeed~ is an
extension that stores the feed config in =elfeed.org= rather than
=custom.el=.

I keep my Elfeed DB in a folder that I sync between my work and home
machine, so I don't have to mark stuff read in multiple places.

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :custom
  (rmh-elfeed-org-files `("~/org/elfeed.org"))
  :config
  (elfeed-org))

(use-package elfeed
  :bind (:map elfeed-search-mode-map
         ("m" . elfeed-toggle-star) )
  :custom
  (elfeed-db-directory "~/Sync/elfeed")
  :config
  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'star)))
#+END_SRC

* Exec Path From Shell

The GUI Emacs gets exec path from the system, rather than the login
shell. We have to load ~PATH~ et. al. from the shell to get access to
programs installed by Homebrew.

Copy ~PATH~ and certain other variables from my login shell so these
variables are available in Eshell. (And elsewhere in Emacs.)

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :custom
  (exec-path-from-shell-arguments nil)
  (exec-path-from-shell-variables
   '("ASPELL_CONF"
     "CPPFLAGS"
     "EDITOR"
     "HOMEBREW_BUNDLE_FILE"
     "HOMEBREW_NO_AUTO_UPDATE"
     "LDFLAGS"
     "MANPATH"
     "NIX_PATH"
     "NIX_PROFILES"
     "NIX_SSL_CERT_FILE"
     "NIX_USER_PROFILE_DIR"
     "PATH"
     "RESTIC_PASSWORD_COMMAND"
     "RESTIC_REPOSITORY"))
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

* Expand Region
Hit ~C-=~ multiple times to expand the highlighted region.
#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+end_src
* Flycheck

#+begin_src emacs-lisp
(use-package flycheck-mode
  :straight flycheck
  :hook clojure-mode)
#+end_src

* Frontend Development
** Prettier.js
#+begin_src emacs-lisp
(use-package prettier-js
  :defer t
  :hook
  ((typescript-mode . prettier-js-mode)
   (web-mode . prettier-js-mode)))
#+end_src
** Typescript
Credit to Robin Schroer.
#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\\.tsx\\'"
  :defer t
  :custom
  (typescript-indent-level 2))
#+end_src

** Typescript Interactive Development Environment (TIDE)
Credit to Robin Schroer.
#+begin_src emacs-lisp
(use-package tide
  :defer t
  :config
  (defun sulami/tide-setup ()
    (when (equal "tsx"
                 (file-name-extension buffer-file-name))
      (tide-setup)
      (flycheck-mode +1)
      (eldoc-mode +1)))
  :hook
  ((typescript-mode . sulami/tide-setup)
   (web-mode . sulami/tide-setup)))
#+end_src
* Git Link

Lets me link to a file location on GitHub/Bitbucket/GitLab
from a local git repository.

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :after magit
  :bind ("C-c g l" . git-link))
#+END_SRC

* HugSQL
HugSQL is a great abstraction for using SQL from Clojure. Robin's
imenu integration makes it easy to search for "functions" in the
HugSQL files.

#+begin_src emacs-lisp
(use-package hugsql
  :straight nil
  :defer t
  :init
  (defun sulami/init-hugsql-imenu ()
    (when (string-suffix-p ".hug.sql" (buffer-file-name))
      (setq imenu-generic-expression
	    '((nil "^--[[:space:]]:name[[:space:]]+\\([[:alnum:]-]+\\)" 1)))))
  :hook
  (sql-mode . sulami/init-hugsql-imenu))
#+end_src

* JSON Mode
This makes Org-mode source blocks do syntax highlighting of JSON
documents, which I like.
#+begin_src emacs-lisp
(use-package json-mode)
#+end_src
* Link to Notmuch emails from Org

I don't like using my email inbox as a todo list. When I receive an
email I need to act on but /can't yet/ for some reason, I link to it
from my Org mode agenda and archive it. When Org agenda prompts me I
can click on the link and immediately get to the mail in my archive,
and can reply to it from there.

#+begin_src emacs-lisp
(use-package ol-notmuch
  :straight org-contrib
  :after (org notmuch))
#+end_src

* Lorem Ipsum placeholder text

Useful for quickly filling in placeholder text.

#+begin_src emacs-lisp
(use-package lorem-ipsum)
#+end_src

* LSP (Language Server Protocol)

LSP is useful for =M-.= (~find-definitions~) and =M-?= (~find-references~),
among other things.

#+begin_src emacs-lisp
;; https://emacs-lsp.github.io/lsp-mode/page/performance/
(setq read-process-output-max (* 1024 1024))
(setq gc-cons-threshold (* 100 1000 1000))
(setq lsp-log-io nil)

(use-package lsp-mode
  :init
  (setq lsp-keymap-prefix "C-c l")
  :hook ((clojure-mode . lsp)
	 (java-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
  :commands lsp
  :custom
  (lsp-enable-file-watchers . nil))

(use-package lsp-treemacs
  :commands lsp-treemacs-errors-list)
#+end_src

* Magit & Forge

I use [[http://magit.vc][Magit]], a git porcelain for Emacs, all day. I rarely use the git
cli any more. I've seen someone suggest learning Emacs just to run
Magit.

Forge is an extension to Magit that lets me create & manipulate pull
requests on GitHub / GitLab etc.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind (("C-S-s-m" . magit-status)
	 ("C-S-s-b" . magit-blame-addition)))

(use-package forge)
#+END_SRC

* Markdown

I'm a sucker for lists, and I want to be able to reorder list items
easily and have them renumbered automatically.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  ;; I essentially don't use Markdown
  ;; outside GitHub any more
  :mode ("\\.md\\'" . gfm-mode)
  :bind (("M-<up>" . markdown-move-list-item-up)
         ("M-<down>" . markdown-move-list-item-down))
  :custom
  (markdown-fontify-code-blocks-natively t)
  (markdown-asymmetric-header t))
#+END_SRC
* Multiple Cursors

This package is another one of those near-magical ones. It allows me to do
multiple edits in the same buffer, using several cursors. You can think of
it as an interactive macro, where you can constantly see what's being done.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-c M-e" . mc/edit-lines)
         ("C-c M-a" . mc/mark-all-dwim)
         ("s-n" . mc/mark-next-like-this)
         ("s-p" . mc/mark-previous-like-this)))
#+END_SRC

* Nix

There are two distinct parts here:

- =nix-mode= :: Provides support for editing Nix expressions
- =nix-sandbox= :: Used to make other commands Nix-aware

#+begin_src emacs-lisp
(use-package nix-mode
  :defer t)

(use-package nix-sandbox
  :defer t)
#+end_src
* Notmuch

I like to use Emacs for /all/ writing, including email. I don't want a
separate program to read and write emails, so it follows I must /read/
email in Emacs too. I currently use [[https://notmuchmail.org][Notmuch]] for this.

Notmuch works pretty well for me out of the box.

Notmuch's Emacs bindings are closely tied to the binary programs, so
they (strongly) recommend that you don't install Notmuch from ELPA.

I configure Notmuch to save a copy of outgoing mail into my sent mail
folder.

#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :load-path "/nix/store/z739yicixjfc6a1m22534zni5lz05w9m-notmuch-0.32.1-emacs/share/emacs/site-lisp/"
  :straight nil
  :demand
  :hook
  (notmuch-message-mode . turn-off-auto-fill)
  :custom
  (message-default-mail-headers (format "Bcc: %s\n" user-mail-address))
  (notmuch-multipart/alternative-discouraged '("text/x-amp-html" "text/plain" "text/html"))
  (notmuch-search-oldest-first nil)
  (notmuch-address-use-company nil)
  (notmuch-hello-thousands-separator ",")
  (notmuch-mua-cite-function (quote message-cite-original-without-signature))
  (notmuch-fcc-dirs nil)
  (notmuch-saved-searches
   `((:name "Inbox" :query "tag:inbox" :key "i")
     (:name "Flagged" :query "tag:flagged" :key "f")
     (:name "Drafts" :query "tag:draft" :key "d")
     (:name "Recent" :query "date:2d.. and not tag:lists" :key "r" :search-type tree)
     (:name "My Threads" :query "thread:\"{from:stig}\" and tag:lists and tag:unread" :key "t" :search-type tree)))
  (notmuch-tagging-keys
   (quote
    (("a" notmuch-archive-tags "Archive")
     ("r" notmuch-show-mark-read-tags "Mark read")
     ("f" ("+flagged") "Flag")
     ("s" ("+spam") "Mark as spam")
     ("d" ("+deleted") "Delete")))))
#+END_SRC

* NVM Support
NVM is the Node Version Manager. It's annoyingly implemented as shell
functionality you source, so it won't work in Eshell. Luckily there's
third-party emacs support.
#+begin_src emacs-lisp
(use-package nvm)
#+end_src
* Org

The Org manual expects the =C-c {l,a,c}= keybindings to be available
in any mode, so define them globally. I prefer to follow conventions.
It makes reading the manual and tutorials a lot easier!

I use Org Agenda for keeping track of my TODOs. I configure TODO list
and tag search to ignore future scheduled, deadlined, and timestamped
issues. These will show in the Agenda eventually anyway.

Set up capture templates to automatically tag tasks with ~@work~ and
~@home~ tags, based on which machine I am on. It's not always correct,
but usually I am in a work frame of mind on my work computer and vice
versa.

Org Babel is magical: execute code from different languages in the
same file, and capture the output! I list the languages I want to
support. I also have to load some modules so they're available when I
need them.

#+BEGIN_SRC emacs-lisp
(use-package org
  ;; Avoid conflicts between multiple Org versions, cf
  ;; https://www.reddit.com/r/emacs/comments/g61lyn/help_needed_orgpriorityhighest/fpria2d/
  :straight org
  :bind (("C-c l" . org-store-link)
	 ("C-c a" . org-agenda)
	 ("C-c c" . org-capture)
	 ;; I try to track time...
	 ("C-c C-x C-j" . org-clock-goto)
	 :map org-mode-map
	 ("M-q" . endless/fill-or-unfill)
	 ("C-x C-<return>" . org-insert-subheading)
	 ("C-S-<return>" . org-insert-todo-subheading)
	 ("C-n" . org-next-link)
	 ("C-p" . org-previous-link))

  :mode (("\\.org\\'" . org-mode)
	 ("\\.org_archive\\'" . org-mode))

  :custom
  ;; Whitespace and edits
  (org-adapt-indentation nil)
  (org-src-preserve-indentation nil)
  (org-edit-src-content-indentation 0)
  (org-hide-emphasis-markers nil)
  (org-link-file-path-type 'relative)
  (org-log-into-drawer t "When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer")
  (org-catch-invisible-edits 'smart)
  (org-export-copy-to-kill-ring 'if-interactive "If running interactively, I want export to copy to the kill-ring")
  (org-export-with-section-numbers nil)
  (org-export-with-toc nil)
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  (org-table-header-line-p t)

  (org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)")
		       (sequence "PROJ(p)" "|" "COMPLETE")
		       (sequence "|" "CANCELLED")))

  (org-tag-alist '(("@home" . ?h)
		   ("@work" . ?w)
		   ("achievement" . ?a)
		   ("brag" . ?b)
		   ("inbox" . ?i)
		   ("interrupt" . ?I)
		   ("meeting" . ?M)
		   ("mit" . ?m)
		   ("noexport" . ?n)
		   ("note" . ?N)
		   ("proj" . ?p)
		   ("someday" . ?s)
		   ("toil" . ?t)))

  (org-stuck-projects '("-someday/PROJ" ("TODO" "WAITING") nil ""))

  (org-refile-use-outline-path 'file "Allow refiling to sub-paths")
  (org-refile-allow-creating-parent-nodes 'confirm)
  (org-refile-targets '((org-agenda-files . (:todo . "PROJ"))
			(org-agenda-files . (:tag . "recurring"))
			(org-agenda-files . (:maxlevel . 1))))
  (org-goto-interface 'outline-path-completion)
  (org-outline-path-complete-in-steps nil)
  (org-agenda-include-diary t)
  (org-agenda-files "~/org/org-agenda-files.txt")

  (org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2 :fileskip0 t))
  (org-agenda-tags-todo-honor-ignore-options t)
  (org-agenda-todo-ignore-scheduled 'future)
  (org-agenda-todo-ignore-deadlines 'far)
  (org-agenda-todo-ignore-with-date 'future)
  (org-agenda-todo-ignore-timestamp 'future)
  (org-agenda-skip-deadline-prewarning-if-scheduled t)
  (org-agenda-skip-timestamp-if-done t)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-scheduled-if-deadline-is-shown t)

  (org-agenda-custom-commands
   `(("d" "Day Agenda & Priority Tasks"
      ((agenda "")
       (tags-todo "PRIORITY=\"A\"/TODO"))
      ((org-agenda-span 'day)
       ;; Exclude @home tasks when I'm on my  work machine, and vice versa
       (org-agenda-tag-filter-preset '(,(if sb/home? "-@work" "-@home")
				       "-someday"
				       "-inbox"))))
     ("x" "E[x]tra tasks" tags-todo ,(concat (if sb/home? "-@work" "-@home")
					     "-someday"
					     "-inbox"
					     "/TODO"))
     ("g" . "Getting Things Done")
     ("gA" "Agenda minus recurring tasks"
      agenda ""
      ((org-agenda-tag-filter-preset '("-recurring"))))
     ("gi" "Inbox" tags "inbox")
     ("gs" "Someday"
      ((todo "PROJ")
       (tags-todo "-proj/TODO"))
      ((org-agenda-tag-filter-preset '("+someday"))))
     ("gc" "Review for Tasks Complete"
      todo "TODO"
      ((org-agenda-tag-filter-preset '("-someday" "-recurring" "-gtd"))))
     ("gw" "Waiting tasks" todo "WAITING")
     ("ga" "Archivable"
      ((tags "-proj-gtd/DONE")
       (tags "-proj-gtd/CANCELLED")))
     ("gp" "Projects" tags-todo "-someday/PROJ")))

  (org-default-notes-file
   (let ((name (downcase (car (split-string (system-name) "\\.")))))
     (expand-file-name (format "%s.org" name) "~/org")))

  (org-capture-templates
   `(("t" "TODO" entry (file "") ,(format "* TODO %%? :inbox:%s:"
					  (if sb/home? "@home" "@work")))
     ("l" "TODO with [l]ink" entry (file "") ,(format "* TODO %%? :inbox:%s:\ncf %%a "
						      (if sb/home? "@home" "@work")))

     ("u" "Utility Metres")
     ("ug" "New Gas Meter Reading" table-line
      (file "~/org/notes/gas-consumption.org")
      (file "templates/gas-consumption.org"))
     ("ue" "New Electricity Meter Reading" table-line
      (file "~/org/notes/electricity-consumption.org")
      (file "templates/electricity-consumption.org"))

     ("p" "Productivity")
     ("pf" "Decide Focus Areas" entry
      (file+olp "~/org/focus-areas.org" ,(format-time-string "%Y"))
      (file "templates/focus-areas.org"))
     ("pb" "Boulders for the Week" entry
      (file+olp "~/org/boulders.org" ,(format-time-string "%Y"))
      "* %<%B/Week %V>\n1. %?")
     ("pr" "New GTD Review" entry
      (file+olp+datetree "~/org/archive/gtd_review.org")
      (file "templates/gtd-review.org") :clock-in t)))

  :config
  (require 'org-habit)
  (require 'ox-rss)
  (require 'ox-icalendar)
  (org-babel-do-load-languages 'org-babel-load-languages
			       '((emacs-lisp . t)
				 (sql . t)
				 (shell . t)
				 (plantuml . t))))
#+end_src

** Ox: GitHub Flavour Markdown
GitHub unfortunately doesn't properly ignore linebreaks in Markdown,
so I use the =gfm= exporter, rather than the standard Markdown one, as
this deletes linebreaks. This means the rendered paragraphs re-flow
properly on GitHub.

#+begin_src emacs-lisp
(use-package ox-gfm)
#+end_src
** Ox: Jira
I love Org's markup so much I wrote a JIRA export backend for it.
#+begin_src emacs-lisp
(use-package ox-jira
  ;; Need to specify the branch here because of
  ;; https://github.com/raxod502/straight.el/issues/279
  :straight (ox-jira :type git
		     :host github
		     :repo "stig/ox-jira.el"
		     :branch "trunk")

  :custom
  ;; This lets foo_bar through "unmolested", while foo_{1} uses a subscript
  ;; See https://github.com/stig/ox-jira.el/issues/53
  (org-export-with-sub-superscripts '{}))
#+end_src

* Org Drill (for learning new things)

I use org-drill for drilling music theory.

#+begin_src emacs-lisp
(use-package org-drill
  :custom
  (org-drill-add-random-noise-to-intervals-p t)
  (org-drill-adjust-intervals-for-early-and-late-repetitions-p t))
#+end_src
* Org Roam
[[https://github.com/org-roam/org-roam][Org-roam]] is a new one for me. It's meant to be an "exo-brain",
modelled after the Zettelkasten method. I'm excited to try it and see
if it improves how I work.

This allows me to capture links to websites from my browser, and store
it as a resource in Org roam.

#+begin_src emacs-lisp
(use-package org-roam
  :demand
  :init
  (setq org-roam-v2-ack t)
  (setq org-roam-directory "~/org/roam")
  :custom
  (org-roam-capture-templates
   '(("d" "Default" plain "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("j" "Jira entry" plain (file "templates/jira.org")
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
			 "#+title: ${title}\n")
      :unnarrowed t)))
  (org-roam-dailies-directory "daily/")
  (org-roam-dailies-capture-templates
   '(("d" "Journal" entry "* %?"
      :if-new (file+head+olp "%<%Y-%m-%d>.org"
			     "#+title: %<%Y-%m-%d>\n#+filetags: %<:%Y:%B:>\n"
			     ("Journal")))
     ("m" "Most Important Thing" entry "* %? :mit:"
      :if-new (file+head+olp "%<%Y-%m-%d>.org"
			     "#+title: %<%Y-%m-%d>\n#+filetags: %<:%Y:%B:>\n"
			     ("Most Important Thing(s)")))
     ("a" "Achievements" entry "* %? :brag:"
      :if-new (file+head+olp "%<%Y-%m-%d>.org"
			     "#+title: %<%Y-%m-%d>\n#+filetags: %<:%Y:%B:>\n"
			     ("Achievements")))))

  (org-roam-capture-ref-templates
   '(("r" "ref" plain "%?"
      :if-new (file+head "website/%<%Y%m%d%H%M%S>-${slug}.org"
			 "#+title: ${title}\n")
      :unnarrowed t)
     ("rs" "ref" plain "%?"
      :if-new (file+head "website/%<%Y%m%d%H%M%S>-${slug}.org"
			 "#+title: ${title}\n\n${selection}\n%?")
      :unnarrowed t)))

  :bind ((("C-c n d" . org-roam-dailies-capture-today)
	  ("C-c n c" . org-roam-capture)
          ("C-c n f" . org-roam-node-find)
	  ("C-c n r" . org-roam-node-random))
	 :map org-mode-map
	 (("C-c n i" . org-roam-node-insert)))
  :config
  (org-roam-setup))

(add-to-list 'display-buffer-alist
             '("\\*org-roam\\*"
               (display-buffer-in-direction)
               (direction . right)
               (window-width . 0.33)
               (window-height . fit-window-to-buffer)))
#+end_src

* Org Superstar

This hides leading stars in Org headlines, and uses UTF symbols to
make them a bit prettier.

#+begin_src emacs-lisp
(use-package org-superstar
  :hook (org-mode . org-superstar-mode))
#+end_src
* Orgalist
Edit "Org-like" lists in non-Org buffers.
#+begin_src emacs-lisp
(use-package orgalist
  :after org
  :hook
  (message-mode . orgalist-mode))
#+end_src

* PlantUML

I sometimes need to draw UML diagrams. For some reason I can't get the
Jar to work in the major mode, but it works fine in Org mode.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :straight (plantuml-mode :type git
			   :host github
			   :repo "stig/plantuml-mode"
			   :branch "sequence-diagram-indentation-test")

  :mode "\\.puml\\'"
  :init
  (defun sb/no-tabs-in-plantuml ()
    (setq indent-tabs-mode nil))
  :hook (plantuml-mode . sb/no-tabs-in-plantuml)
  :custom
  (plantuml-indent-level 4)
  (plantuml-default-exec-mode 'executable)
  (plantuml-font-lock-keywords t))

(use-package ob-plantuml
  :after org
  :straight nil
  :init
  (setq org-plantuml-exec-mode 'plantuml))
#+end_src

* Projectile

I use Projectile to navigate my projects. Some of the things I like about
it are that it provides the following key bindings:

- =C-c p f= :: Find a file in this project.
- =C-c p k= :: Close all buffers for this project.
- =C-c p t= :: This switches from an implementation file to its test file,
               or vice versa. I use this extensively in Clojure mode. It
               might not make sense for all languages; YMMV.
- =C-c p s r= :: Ripgrep for something in this project. If point is at
                 a token, default to searching for that.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish
  :bind-keymap ("C-c p" . projectile-command-map)
  :custom
  (projectile-completion-system 'default)
  (projectile-create-missing-test-files t)
  (projectile-project-search-path '("~/src"))
  (projectile-switch-project-action 'projectile-find-file)
  :config
  (defun sulami/projectile-rg ()
    (interactive)
    (consult-ripgrep (projectile-project-root)))

  (defun sulami/projectile-rg-thing-at-point ()
    (interactive)
    (consult-ripgrep (projectile-project-root)
                     (thing-at-point 'symbol t)))

  ;; Don't do projectile stuff on remote files
  ;; from https://github.com/syl20bnr/spacemacs/issues/11381#issuecomment-481239700
  (defadvice projectile-project-root (around ignore-remote first activate)
    (unless (file-remote-p default-directory) ad-do-it))

  (projectile-mode))
#+END_SRC

* Protobuf Mode
We use protobufs for service-to-service communication at work. Stolen
from Robin Schroer.

#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :defer t
  :init
  (defun sulami/init-protobuf-imenu ()
    "Sets up imenu support for Protobuf.

Stolen from Spacemacs."
    (setq
     imenu-generic-expression
     '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2))))
  :hook
  (protobuf-mode . sulami/init-protobuf-imenu))
#+END_SRC

* Ripgrep

Even faster than The Silver Searcher, apparently.

#+begin_src emacs-lisp
(use-package ripgrep
  :custom
  ;; I often look for stuff in .circleci/config.yml
  (ripgrep-arguments '("--hidden")))
#+end_src

* Server Start

This is necessary for =emacsclient= and therefore =org-roam-protocol=.
#+begin_src emacs-lisp
(unless (server-running-p)
  (server-start))
#+end_src
* Selectrum
Incremental searching and selecting.
#+begin_src emacs-lisp
(use-package selectrum
  :hook
  (after-init . selectrum-mode))
#+end_src
** Selectrum Prescient Mode
Learn which completions I prefer, to improve performance over time.
#+begin_src emacs-lisp
(use-package selectrum-prescient
  :hook
  (after-init . selectrum-prescient-mode)
  (after-init . prescient-persist-mode))
#+end_src
** Consult
Adds selectrum support for some commands that do not use ~read-string~
normally.

#+begin_src emacs-lisp
(use-package consult
  :defer t
  :straight
  '(consult
    :type git
    :host github
    :repo "minad/consult"
    :branch "main")
  :custom
  (consult-preview-key nil)
  :config
  ;; Eshell only defines its locally keymap when you launch it, so we
  ;; have to add bindings with a hook.
  (defun sb/consult-setup-eshell-bindings ()
    (bind-key "C-r" #'consult-history 'eshell-mode-map))

  :bind (("M-y" . consult-yank-pop)
	 ("C-c i" . consult-imenu)
	 :map shell-mode-map
	 ("C-r" . consult-history))
  :hook
  (eshell-mode . sb/consult-setup-eshell-bindings))
#+end_src

** Orderless

This package provides a minibuffer completion style that is
"whitespace separated words in any order." Very useful if you don't
know exactly what you're looking for.

#+begin_src emacs-lisp
(use-package orderless
  :defer t
  :custom
  (completion-styles '(orderless)))
#+end_src

* Sending mail with MSMTP

MSMTP's [[file:../msmtp/config][configuration]] is really simple, and it will detect the account
to use from the "from" address.

Passwords are stored in the system Keychain. See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]]
section in the msmtp documentation for details.

: security add-internet-password -s mail.gandi.net -r smtp -a stig@brautaset.org -w

Finally we have to tell Emacs to use msmtp to send mail.  (And to
kill the message buffer on exit.)

#+BEGIN_SRC emacs-lisp
(setq sendmail-program "msmtp"
      message-send-mail-function 'message-send-mail-with-sendmail
      message-kill-buffer-on-exit t
      message-directory "~/.mail"
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header
      mail-specify-envelope-from t)
#+END_SRC

* SmartParens

Structural editing is a must when editing lisp, and it has bled
into other aspects of programming for me.  In particular the
ability to remove surrounding parens / quotes with ~sp-splice-sexp~
is incredibly useful even when writing prose.

#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :straight smartparens
  :demand
  :custom
  (sp-base-key-bindings 'sp)
  (sp-show-pair-from-inside t)
  :config
  (sp-local-pair 'text-mode "'" nil :actions :rem)
  (show-smartparens-global-mode t))
(add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
(add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)
(add-hook 'org-mode-hook 'turn-on-smartparens-strict-mode)
#+END_SRC

* Spell Checking

I use aspell, with British English dictionary.

#+BEGIN_SRC emacs-lisp
(use-package ispell)
#+END_SRC

* String Inflection

Sometimes I need to swap between CamelCase and snake_case, or even
SNAKE_CASE.

#+begin_src emacs-lisp
(use-package string-inflection)
#+end_src

* Subword

Treats CapitalizedWords as separate, so we can move forward by
their components.  Useful in anything that looks like Java.

#+begin_src emacs-lisp
(use-package subword
  :hook (prog-mode . subword-mode))
#+end_src

* Sudo-edit
Allows me to switch to root for editing a file. (Usually =/etc/hosts=.)
#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src
* Tramp

Trying to speed up Tramp over SSH with these settings from the [[https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html][FAQ]].

#+begin_src emacs-lisp
(setq tramp-ssh-controlmaster-options "-o ControlMaster=auto -o ControlPath='tramp.%%C'"
      remote-file-name-inhibit-cache 300
      tramp-completion-reread-directory-timeout 300
      vc-ignore-dir-regexp (format "%s\\|%s"
				   vc-ignore-dir-regexp
				   tramp-file-name-regexp))
#+end_src

* Verb

This is a package I use for interacting with REST HTTP APIs. Before
arriving at it I tried restclient, walkman, and http.el. All have
their strengths and weaknesses, but Verb seems the most well-rounded
feature set. The hierachical inheritance is what really sold me, as it
works really well with REST APIs to reduce boilerplate.

#+begin_src emacs-lisp
(use-package verb
  :init
  (defun sb/api-token-for-host (host)
    "Return a token for the specified host."
    (let ((found (nth 0 (auth-source-search :host host :create nil))))
      (when found
	(let ((secret (plist-get found :secret)))
	  (if (functionp secret)
	      (funcall secret)
	    secret)))))
  :config
  (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+end_src

* Wgrep (aka "writable grep")

~wgrep~ mode is pretty close to magic. When in a buffer showing
grep/ag/ripgrep results, I can hit =C-c C-p= to let me /edit the
results of the search right from the results buffer!/ I can then
hit =C-x C-s= to save the results.

Hitting =C-c C-p= while already in writable grep mode I can delete
the entire matched line by hitting =C-c C-d=.

#+begin_src emacs-lisp
(use-package wgrep
  :straight (wgrep :type git
		   :host github
		   :repo "mhayashi1120/Emacs-wgrep"))
#+end_src

* Which Key Mode

Show incomplete key cheatsheet.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+END_SRC

* Whitespace annoyances
Highlight certain whitespace annoyances, and clean them up automatically.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :custom
  (whitespace-style '(face empty tabs trailing))
  (whitespace-action '(auto-cleanup))
  :config
  (global-whitespace-mode t))
#+END_SRC

* Writegood Mode

I'm not a great writer. I need all the crutches I can get. Lucklily,
Emacs has them.

This helps highlight passive voice, weasel words, etc in writing.

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :hook text-mode)
#+END_SRC

* YAML
CircleCI and CloudFormation loves YAML.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC

* YAS

A templating engine for Emacs.

#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (yas-global-mode))
#+end_src
