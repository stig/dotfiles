#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t
#+PROPERTY: header-args:emacs-lisp    :tangle ~/.config/emacs/init.el :results silent :mkdirp t
#+STARTUP: content

This is my Emacs configuration. It is a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose interspersed with code blocks. I edit this file, and /tangle/ it into [[file:~/.config/emacs/init.el][init.el]] (and [[/Users/stig/.config/emacs/early-init.el][early-init.el]]) by hitting =C-c C-v C-t=.

I install Emacs itself using nixpkgs, along with other tools (~ripgrep~, etc).

* Early Initialisation
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/.config/emacs/early-init.el :results silent :mkdirp t
:END:

Emacs loads =early-init.el= before loading GUI components. That makes it a great place to turn off the mouse interface, to avoid momentary display during launch. I also disable the splash screen, the audible bell, and the ~package.el~ subsystem.

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

(setq inhibit-startup-screen t
      visible-bell t
      package-enable-at-startup nil)
#+end_src

Let's also set some performance tuning options here.

#+begin_src emacs-lisp
;; https://emacs-lsp.github.io/lsp-mode/page/performance/
(setq read-process-output-max (* 1024 1024))
(setq gc-cons-threshold (* 100 1000 1000))

(setq max-lisp-eval-depth 2000)
(setq max-specpdl-size 3200)
#+end_src

* Use lexical bindings
Using lexical bindings speeds up loading config, if I understand correctly.
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src
* Who am I?

Set up my name, email address, and login. I use the email in my Notmuch config below, and some of these show up in Org mode's export metadata.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Stig Brautaset"
      user-mail-address "stig@brautaset.org"
      user-login-name "stig")
#+END_SRC

* Better Defaults

** Configure Control/Meta/super/hyper keys

#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'meta
      mac-control-modifier 'control
      mac-function-modifier 'hyper
      mac-option-modifier 'super)
#+END_SRC

** Confirm kill emacs

The default keybinding for this is close to =M-q= which I use for reflowing text.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

** Diminish Auto-revert and Eldoc mode
#+begin_src emacs-lisp
(require 'diminish)
(diminish 'auto-revert-mode)
(diminish 'eldoc-mode)
#+end_src
** Display line numbers

Displaying line numbers is incredibly useful when remotely pairing with other people.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Don't require two spaces to end a sentence

Having this enabled makes it harder to collaborate with others, and move sentences around in texts I haven't written.

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

** End all files in a newline

All files should end in a newline. Insert one if there isn't one already.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

** Ensure we don't use unencrypted auth sources

This could take the form of e.g. saving auth info to =~/.authinfo=, or =~/.netrc= rather than =~/.authinfo.gpg=, for example.

#+begin_src emacs-lisp
(setq auth-sources (quote ("~/.authinfo.gpg")))
#+end_src

** Flymake key bindings
#+begin_src emacs-lisp
(require 'flymake)
(keymap-set flymake-mode-map "M-n" 'flymake-goto-next-error)
(keymap-set flymake-mode-map "M-p" 'flymake-goto-prev-error)
#+end_src
** GnuPG

Emacs will open =.gpg= files transparently, but I need to install gnupg & pinentry for that to work.

#+begin_src emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+end_src

** Consult

#+begin_src emacs-lisp
(require 'consult)
(keymap-global-set "C-c r" #'consult-ripgrep)

(require 'consult-imenu)
(keymap-global-set "C-c i" #'consult-imenu)
#+end_src

** Make 'y' and 'n' satisfy prompts

Answering just 'y' or 'n' will do, rather than having to spell out "yes" or "no".

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Prefer YMD for dates in Diary / Calendar
#+BEGIN_SRC emacs-lisp
(setq calendar-date-style 'iso)
#+END_SRC

** Put Customize settings in a separate file
I prefer to code my configuration, most of the time, but sometimes it's good enough. I do want them in a separate file though.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Save minibuffer history

This allows us to "tap up" in the minibuffer to recall previous items, even from a previous session.

#+BEGIN_SRC emacs-lisp
(savehist-mode)
#+END_SRC

** Save my place in each file

It's nice if Emacs knows where I was last time I opened a file.

#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC

** Show Matching parens

Put the cursor on any of =()[]{}= and Emacs shows the matching closing/opening one.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

** Spell check as I write (including comments & strings in code)
#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'flyspell-mode)
(add-hook 'prog-mode-hook #'flyspell-prog-mode)
#+end_src

** Store backup files in a separate folder

I don't like backup files all over my disk. This places them in a separate directory.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory))))
#+END_SRC

** Support recursive minibuffers

I like to be able to use my kill-ring in the minibuffer.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src
** Transparently open compressed files

I *do* like it when Emacs transparently opens compressed files. It gives me the warm fuzzies.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC

** Upcase-dwim and dowcase-dwim

Acts like ~upcase-word~ with no region selected, and ~upcase-region~ when one is.

#+begin_src emacs-lisp
(keymap-global-set "M-u" #'upcase-dwim)
(keymap-global-set "M-l" #'downcase-dwim)
#+end_src
** UTF-8: everywhere, always

Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** Visual fill column mode / visual line mode

This is a great combination. In particular it means that text is flowing automatically, rather than me having to use the manual fill commands. This is great for editing.

#+BEGIN_SRC emacs-lisp
(defun sb/visual-fill-column-hook ()
  (setq visual-fill-column-center-text t)
  (setq visual-fill-column-width 90))

(add-hook 'visual-fill-column-mode-hook 'sb/visual-fill-column-hook)

(add-hook 'text-mode-hook 'visual-fill-column-mode)
(add-hook 'text-mode-hook 'visual-line-mode)

(diminish 'visual-fill-column-mode)
(diminish 'visual-line-mode)
#+END_SRC

* Appearance
** Default font & size

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "JetBrains Mono" :height 150)
(set-face-attribute 'fixed-pitch nil :font "JetBrains Mono" :height 150)
(set-face-attribute 'variable-pitch nil :font "Optima" :height 1.3)

(add-hook 'text-mode-hook 'variable-pitch-mode)
#+END_SRC

** Configure variable pitch mode

Some things should be fixed-width still.

#+begin_src emacs-lisp
(require 'org-faces)

(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

* Custom Functions
** Blogging
I create blog entries in a directory under =~/blog= and link to them from the main index page. It has so far been a manual job, but I have finally managed to create a function to automate it a bit.

*** Helper function to get a value from Org keyword element

#+begin_src emacs-lisp
(defun sb/org-kw-get (key)
  "Return a lambda that takes an Org keyword element and returns
its :value property if its :key property matches `key'."
  `(lambda (kw)
     (if (equal ,key (org-element-property :key kw))
         (org-element-property :value kw))))
#+end_src

*** Create blog post index entry

#+BEGIN_SRC emacs-lisp
(defun sb/blog-post-index-entry ()
  "Call in a blog post to get an entry suitable for linking to this
post from the index page."
  (interactive)
  (let* ((path (s-chop-prefix (expand-file-name "~/blog/content/") (buffer-file-name)))
         (tree (org-element-parse-buffer))
         (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
         (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY"))))
    (with-temp-buffer
      (org-mode)
      (org-insert-heading)
      ;; Would have loved to use `org-insert-link' here but
      ;; I can't stop it from presenting a prompt.
      (insert "[[file:" path "][" title "]]\n"
              "#+include: " path "::abstract :only-contents t\n")
      ;; Need to go back to the first line to set tags, as
      ;; org-set-tags assumes point is on a headline.
      (goto-char (point-min))
      (org-set-tags categories)
      ;; Return the contents temporary buffer as a string *without properties*
      (copy-region-as-kill
       (point-min) (point-max)))))
#+END_SRC

*** Create RSS entry

Creating an entry in the RSS feed is another manual step. This way I can "soft publish" and publish to RSS separately from the index page.

#+begin_src emacs-lisp
(defun sb/blog-post-rss-entry ()
  "Call in a blog post to get an entry suitable for linking to this
post from the index page."
  (interactive)
  (let* ((path (s-chop-prefix (expand-file-name "~/blog/content/") (buffer-file-name)))
         (tree (org-element-parse-buffer))
         (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
         (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY"))))
    (with-temp-buffer
      (org-mode)
      (org-insert-heading)
      (insert title "\n"
	      "#+include: " path "::abstract :only-contents t\n")
      (org-set-property "RSS_PERMALINK"
                        (format "%s.html"
                                (file-name-sans-extension path)))
      (copy-region-as-kill
       (point-min) (point-max)))))
#+end_src

*** Blog server

While noodling around with my blog locally I publish to =~/blog= and use a simple Python server to host it.

#+begin_src emacs-lisp
(defun sb/blog-server ()
  (interactive)
  (start-process "Blog Server" "*blog server*"
                 "python3"
                 "-m" "http.server"
                 "--directory" (expand-file-name "~/blog/_site"))
  (message "Blog Server started"))
#+end_src

** Delete buffer and file it is visiting

Copied from [[https://github.com/sulami/dotfiles/blob/master/emacs/.emacs/README.org#delete-buffer-file][sulami]]'s config.

#+begin_src emacs-lisp
(defun sb/delete-file-and-buffer ()
  "Deletes a buffer and the file it's visiting."
  (interactive)
  (when-let* ((file-name (buffer-file-name))
              (really (yes-or-no-p (format "Delete %s? "
                                           file-name))))
    (delete-file file-name)
    (kill-buffer)))
#+end_src

** Ediff: Automatically Unfold Org files

This snippet makes sure that Org buffers don't start folded, as ediff is rather useless in that case. (Credit: Oleh Krehel on emacs-orgmode mailing list.)

#+BEGIN_SRC emacs-lisp
(defun sb/ediff-prepare-buffer ()
  (when (memq major-mode '(org-mode emacs-lisp-mode))
    (outline-show-all)))

(add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
#+END_SRC

** Ediff: Picking /both/ sides in a conflict

If both branches add an entry to a list I may want to pick *both* sides. This adds =d= as a shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) I can use =~= to swap the A and B buffers, which lets me choose A then B, /or/ B then A.

#+BEGIN_SRC emacs-lisp
(defun sb/ediff-copy-both-to-C ()
  (interactive)
  (ediff-copy-diff ediff-current-difference nil 'C nil
                   (concat
                    (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                    (ediff-get-region-contents
                     ediff-current-difference 'B
                     ediff-control-buffer))))

(defun sb/add-d-to-ediff-mode-map ()
  (keymap-set ediff-mode-map "d" 'sb/ediff-copy-both-to-C))

(add-hook 'ediff-keymap-setup-hook 'sb/add-d-to-ediff-mode-map)
#+END_SRC

** Toggle Window Split function

This function re-arranges horizontally-split windows to be vertically-split, and vice versa. I found it on StackOverflow, once upon a time but now can't find the link.

#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(keymap-set ctl-x-4-map "t" 'toggle-window-split)
#+END_SRC

** Unfill paragraphs and regions

The default binding for =M-q= fills a paragraph. Very good. But sometimes I want to /unfill/, particularly when editing markdown that is going to end up on GitHub. Otherwise the result has lots of hard linebreaks. This happens every time I edit a PR description in Magit, for example. [[Https://gist.github.com/heikkil/a3edf506046c84f6f508edbaf005810a][Credit]].

#+begin_src emacs-lisp
(defun endless/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command #'endless/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (if (eq major-mode 'org-mode)
        (call-interactively #' org-fill-paragraph)
      (call-interactively #'fill-paragraph))))

(keymap-global-set "M-q" #'endless/fill-or-unfill)
#+end_src

* Exec Path From Shell

The GUI Emacs gets exec path from the system, rather than the login shell. We have to load ~PATH~ et. al. from the shell to get access to programs installed by Nix.

Copy ~PATH~ and ~MANPATH~ from my login shell so these
variables are available in Eshell. (And elsewhere in Emacs.)

#+BEGIN_SRC emacs-lisp
(require 'exec-path-from-shell)
(exec-path-from-shell-initialize)
#+END_SRC
* YAS

A templating engine for Emacs.

#+begin_src emacs-lisp
(require 'yasnippet)
(add-hook 'prog-mode-hook #'yas-minor-mode)

(diminish 'yas-minor-mode)
#+end_src
* Ace Window

This lets me rapidly switch to a different frame/window. I use this mainly when resolving conflicts in ediff merge, since I need to swap between two frames there.

#+begin_src emacs-lisp
(require 'ace-window)
(keymap-global-set "C-S-s-<tab>" 'ace-window)
(keymap-global-set "M-`" 'ace-window)
#+end_src

* Adoc Mode
I'm not a fan, but some repos I interact with use Adoc and it's a PITA to edit such documents without a helping hand.

#+begin_src emacs-lisp
(autoload 'adoc-mode "adoc-mode" nil t)
(add-to-list 'auto-mode-alist '("\\.adoc\\'" . adoc-mode))
#+end_src
* Bug Reference Mode
Automatically create JIRA links for things that looks like them. For this I've adapted snippets from Alex ter Weele and Robin Schroer.
#+begin_src emacs-lisp
(defun sb/bug-reference-setup ()
  (setq bug-reference-bug-regexp
        (rx
         (group
          (group
           ;; Jira projects have at least 2 characters, hence we call
           ;; any + one-or-more to avoid false positives.
	   symbol-start
           (any upper)
           (one-or-more upper)
           "-"
           (any "1-9") (zero-or-more digit)
	   symbol-end)))
        bug-reference-url-format "https://circleci.atlassian.net/browse/%s"))

(add-hook 'bug-reference-mode-hook 'sb/bug-reference-setup)
(add-hook 'text-mode-hook 'bug-reference-mode)
(add-hook 'prog-mode-hook 'bug-reference-mode)
#+end_src
* Clojure

Clojure is the main programming language I use at work.

I use Clojure Mode augmented by flymake-kondor. I use CIDER as my primary REPL.

#+BEGIN_SRC emacs-lisp
(require 'clojure-mode)
(require 'flymake-kondor)
(add-hook 'clojure-mode-hook 'flymake-kondor-setup)

;; Allow cider's xref, but at low priority. Don't use it by default as
;; Eglot's xref tends to work better.
(setq cider-use-xref t)
(setq cider-xref-fn-depth 90)

(setq cider-repl-display-help-banner nil)
(setq cider-eldoc-display-context-dependent-info t)
#+END_SRC

Kaocha-runner lets me run test using kaocha-runner in CIDER.

#+begin_src emacs-lisp
(with-eval-after-load "clojure-mode"
  (require 'kaocha-runner)
  (keymap-set clojure-mode-map "C-c k t" 'kaocha-runner-run-test-at-point)
  (keymap-set clojure-mode-map "C-c k r" 'kaocha-runner-run-tests)
  (keymap-set clojure-mode-map "C-c k a" 'kaocha-runner-run-all-tests)
  (keymap-set clojure-mode-map "C-c k w" 'kaocha-runner-show-warnings)
  (keymap-set clojure-mode-map "C-c k h" 'kaocha-runner-hide-windows))
#+end_src

Additional refactoring support. I've honestly struggled to get this to
work properly at times, but it's probably not the tool's fault. I
assume it's something weird we do in our project(s).

I still keep it around for its "magic requires", which I very much
appreciate. I should improve this though.

#+begin_src emacs-lisp
(setq cljr-auto-sort-ns nil)
(setq cljr-auto-clean-ns nil)
(setq cljr-add-ns-to-blank-clj-files nil)

(with-eval-after-load "clojure-mode"
  (with-eval-after-load "yasnippet"
    (require 'clj-refactor)

    (add-to-list 'cljr-magic-require-namespaces '("s" . "clojure.spec.alpha"))
    (add-to-list 'cljr-magic-require-namespaces '("gen" . "clojure.spec.gen.alpha"))

    (keymap-set clojure-mode-map "C-c C-r h" #'hydra-cljr-help-menu/body)

    (add-hook 'clojure-mode-hook #'clj-refactor-mode)))
#+end_src
* Company (COMplete ANYthing)
#+begin_src emacs-lisp
(require 'company)
(global-company-mode)
(diminish 'company-mode)
#+end_src
* CSV Mode
Useful for removing columns from a CSV file, for example. Or lining up columns by width, for easier viewing.
#+begin_src emacs-lisp
(require 'csv-mode)
#+end_src
* Direnv
Set environment per directory. The plan is to use this with Nix-direnv, to automatically set my PATH for a directory.

#+begin_src emacs-lisp
(require 'direnv)
(add-hook 'after-init-hook #'direnv-mode)
#+end_src
* Docker
#+begin_src emacs-lisp
(require 'docker)
#+end_src
* Dumb-jump

Trying this out again, now that it registers an xref backend:

#+begin_src emacs-lisp
(require 'dumb-jump)
(add-hook 'xref-backend-functions #'dumb-jump-xref-activate 100)
#+end_src
* Edit Indirect
To edit code examples in a separate buffer from Markdown. (Similar to code blocks in Org.)

#+begin_src emacs-lisp
(require 'edit-indirect)
#+end_src

* Elfeed
Elfeed is an Emacs (RSS & Atom) feed reader. ~org-elfeed~ is an extension that stores the feed config in =elfeed.org= rather than =custom.el=.

#+BEGIN_SRC emacs-lisp
(require 'elfeed)
(require 'elfeed-org)

(setq rmh-elfeed-org-files '("~/Documents/Elfeed/feeds.org"))
(add-hook 'after-init-hook #'elfeed-org)

(setq elfeed-db-directory "~/Documents/Elfeed/db")
#+END_SRC

* Email
** Notmuch

I like to use Emacs for /all/ writing, including email. I don't want a separate program to read and write emails, so it follows I must /read/ email in Emacs too. I currently use [[https://notmuchmail.org][Notmuch]] for this.

Notmuch works pretty well for me out of the box.

Notmuch's Emacs bindings are closely tied to the binary programs, so they (strongly) recommend that you don't install Notmuch from ELPA.

#+BEGIN_SRC emacs-lisp
(require 'notmuch)
(add-hook 'notmuch-message-mode-hook #'turn-off-auto-fill)
(setq notmuch-multipart/alternative-discouraged '("text/x-amp-html" "text/plain" "text/html"))
(setq notmuch-search-oldest-first nil)
(setq notmuch-hello-thousands-separator ",")
(setq notmuch-archive-tags (list "-inbox" "+archived"))
(setq notmuch-mua-cite-function (quote message-cite-original-without-signature))
(setq notmuch-fcc-dirs '(("sonar_columns_0n@icloud.com" . "icloud/Sent +sent")
			 ("stig@circleci.com" . "work/Sent +sent")))
(setq notmuch-saved-searches
      (quote
       ((:name "Personal Inbox" :query "tag:personal and tag:inbox" :key "p" :search-type tree)
	(:name "CCI Inbox" :query "tag:work and tag:inbox" :key "c" :search-type tree)
	(:name "Flagged" :query "tag:flagged" :key "f" :search-type tree)
	(:name "Waiting For" :query "tag:waiting_for" :key "w" :search-type tree)
	(:name "Drafts" :query "tag:draft" :key "d")
	(:name "Recent" :query "date:7d.. and not tag:lists" :key "r" :search-type tree))))

(setq notmuch-tagging-keys
      (quote
       (("a" notmuch-archive-tags "Archive")
	("u" notmuch-show-mark-read-tags "Mark read")
	("f" ("+flagged") "Flag")
	("s" ("+spam" "-inbox") "Mark as spam")
	("d" ("+deleted" "-inbox") "Delete")
	("w" ("-inbox" "+waiting_for") "Waiting For"))))
#+END_SRC

** Sending mail with MSMTP

MSMTP's [[file:../msmtp/config][configuration]] is really simple, and it will detect the account to use from the "from" address.

Passwords are stored in the system Keychain. See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]] section in the msmtp documentation for details.

: security add-internet-password -s mail.gandi.net -r smtp -a stig@brautaset.org -w

Finally we have to tell Emacs to use msmtp to send mail. (And to kill the message buffer on exit.)

#+BEGIN_SRC emacs-lisp
(setq sendmail-program "msmtp"
      message-send-mail-function 'message-send-mail-with-sendmail
      message-kill-buffer-on-exit t
      message-directory "~/Maildir"
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header
      mail-specify-envelope-from t)
#+END_SRC

** Link to Notmuch emails from Org

I don't like using my email inbox as a todo list. When I receive an email I need to act on but /can't yet/ for some reason, I link to it from my Org mode agenda and archive it. When Org agenda prompts me I can click on the link and immediately get to the mail in my archive, and can reply to it from there.

#+begin_src emacs-lisp
(with-eval-after-load "notmuch"
  (with-eval-after-load "org"
    (require 'ol-notmuch)))
#+end_src

** Org Mime
For sending HTML emails.

#+begin_src emacs-lisp
(require 'org-mime)
#+end_src
** Simple HTML Renderer (HTML Email)

I use shr for reading HTML mail. I normally use a fullscreen window, but I don't like reading HTML mails with lines running all the way across. Thus I prefer linebreaks roughly every 80 characters.

#+begin_src emacs-lisp
(setq shr-width 80)
#+end_src

* Expand Region
Hit ~C-=~ multiple times to expand the highlighted region.
#+begin_src emacs-lisp
(require 'expand-region)
(keymap-global-set "C-=" #'er/expand-region)
#+end_src
* Git Link

Lets me link to a file location on GitHub/Bitbucket/GitLab
from a local git repository.

#+BEGIN_SRC emacs-lisp
(require 'git-link)
(keymap-global-set "C-c g l" #'git-link)
#+END_SRC

* Go
I sometimes must interact with Go at work.
#+begin_src emacs-lisp
(require 'go-mode)
#+end_src
* HugSQL
HugSQL is a great abstraction for using SQL from Clojure. Robin's imenu integration makes it easy to search for "functions" in the HugSQL files.

#+begin_src emacs-lisp
(defun sulami/init-hugsql-imenu ()
  (when (string-suffix-p ".hug.sql" (buffer-file-name))
    (setq imenu-generic-expression
	  '((nil "^--[[:space:]]:name[[:space:]]+\\([[:alnum:]-]+\\)" 1)))))
(add-hook 'sql-mode-hook #'sulami/init-hugsql-imenu)
#+end_src

* Jarchive

This lets me open project dependencies inside jar archives, pairs well with Eglot!

#+begin_src emacs-lisp
(require 'jarchive)
(add-hook 'clojure-mode-hook #'jarchive-setup)
#+end_src
* JSON Mode
This makes Org-mode source blocks do syntax highlighting of JSON documents, which I like.
#+begin_src emacs-lisp
(require 'json-mode)
#+end_src
* Language Server Protocol (Eglot)

Disable the timeout, as it occasionally triggers on startup for newer clojure-lsp. This is due to some analysis pass, particularly on the first time we open a project, taking a bit of time.

#+begin_src emacs-lisp
(require 'eglot)

(setq eglot-connect-timeout nil)
(setq eglot-extend-to-xref t)

(keymap-set eglot-mode-map "C-c e r" 'eglot-rename)
(keymap-set eglot-mode-map "C-c e a" 'eglot-code-actions)
(keymap-set eglot-mode-map "C-c h" 'eldoc)
(keymap-set eglot-mode-map "M-i" 'eglot-find-implementation)

(mapc (lambda (hook)
        (add-hook hook #'eglot-ensure))
      (quote (clojure-mode-hook
              dockerfile-mode-hook
              go-mode-hook
              json-mode-hook
              nix-mode-hook
              shell-mode-hook
              yaml-mode-hook)))
#+end_src

* Magit & Forge

I use [[http://magit.vc][Magit]], a git porcelain for Emacs, all day. I rarely use the git cli any more. I've seen someone suggest learning Emacs just to run Magit.

Forge is an extension to Magit that lets me create & manipulate pull requests on GitHub / GitLab etc.

#+BEGIN_SRC emacs-lisp
(require 'magit)
(require 'forge)
(keymap-global-set "C-S-s-m" #'magit-status)
(keymap-global-set "C-S-s-b" #'magit-blame-addition)

(with-eval-after-load "project"
  (keymap-set project-prefix-map "m" #'magit-status)

  ;; Replace vc-el with Magit in project commands
  (setq project-switch-commands
	(remove '(project-vc-dir "VC-Dir") project-switch-commands))
  (add-to-list 'project-switch-commands '(magit-status "Magit" nil) t))
#+END_SRC

* Marginalia
Provide more information in Minibuffer margins
#+begin_src emacs-lisp
(require 'marginalia)
(marginalia-mode)
#+end_src
* Markdown

I'm a sucker for lists, and I want to be able to reorder list items easily and have them renumbered automatically.

#+BEGIN_SRC emacs-lisp
(require 'markdown-mode)
(add-to-list 'auto-mode-alist '("\\.md\\'" . gfm-mode))
(setq markdown-fontify-code-blocks-natively t)
(setq markdown-asymmetric-header t)

(with-eval-after-load "markdown-mode"
  ;; I essentially don't use Markdown
  ;; outside GitHub any more
  (keymap-set markdown-mode-map "M-<up>" #'markdown-move-list-item-up)
  (keymap-set markdown-mode-map "M-<down>" #'markdown-move-list-item-down))
#+END_SRC
* Multiple Cursors

This package is another one of those near-magical ones. It allows me to do multiple edits in the same buffer, using several cursors. You can think of it as an interactive macro, where you can constantly see what's being done.

#+BEGIN_SRC emacs-lisp
(require 'multiple-cursors)
#+END_SRC

* Nix

There are two distinct parts here:

- =nix-mode= :: Provides support for editing Nix expressions
- =nix-sandbox= :: Used to make other commands Nix-aware

#+begin_src emacs-lisp
(require 'nix-mode)
(require 'nix-sandbox)
#+end_src
* Orderless
#+begin_src emacs-lisp
(require 'orderless)

(setq completion-styles '(orderless basic)
      completion-category-defaults nil
      completion-category-overrides '((file (styles partial-completion))))
#+end_src

* Org mode

The Org manual expects the =C-c {l,a,c}= keybindings to be available in any mode, so define them globally. I prefer to follow conventions. It makes reading the manual and tutorials a lot easier!

I use Org Agenda for keeping track of my TODOs. I configure TODO list and tag search to ignore future scheduled, deadlined, and timestamped issues. These will show in the Agenda eventually anyway.

Org Babel is magical: execute code from different languages in the same file, and capture the output! I list the languages I want to support. I also have to load some modules so they're available when I need them.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(add-to-list 'auto-mode-alist '("\\.org_archive\\'" . org-mode))

(keymap-global-set "C-c l" #'org-store-link)
(keymap-global-set "C-c a" #'org-agenda)
(keymap-global-set "C-c c" #'org-capture)

(with-eval-after-load "org"
  (keymap-set org-mode-map "M-q" #'endless/fill-or-unfill)
  (keymap-set org-mode-map "C-x C-<return>" #'org-insert-subheading)
  (keymap-set org-mode-map "C-S-<return>" #'org-insert-todo-subheading)
  (keymap-set org-mode-map "C-n" #'org-next-link)
  (keymap-set org-mode-map "C-p" #'org-previous-link))

;; don't indent relative to headline
(setq org-adapt-indentation nil)

;; no initial indent in source code
(setq org-edit-src-content-indentation 0)

(setq org-hide-emphasis-markers t)

;; When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer
(setq org-log-into-drawer t)
(setq org-catch-invisible-edits 'smart)

;; If running interactively, I want export to copy to the kill-ring
(setq org-export-copy-to-kill-ring 'if-interactive)

;; I don't normally  want section numbers in exports
(setq org-export-with-section-numbers nil)

;; Omit TOC unless I explicitly put it in
(setq org-export-with-toc nil)
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

(setq org-table-header-line-p t)
(diminish 'org-table-header-line-mode)

(setq org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)")
			  (sequence "PROJ(p)" "|" "COMPLETE")
			  (sequence "|" "CANCELLED")))

(setq org-stuck-projects '("-someday/PROJ" ("TODO" "WAITING") nil ""))

;; Allow refiling to sub-paths
(setq org-refile-use-outline-path 'file)
(setq org-refile-allow-creating-parent-nodes 'confirm)
(setq org-refile-targets '((nil . (:todo . "PROJ"))
			   (nil . (:level . 1))
			   (nil . (:level . 2))))
(setq org-goto-interface 'outline-path-completion)
(setq org-outline-path-complete-in-steps nil)
(setq org-agenda-include-diary t)
(setq org-directory "~/Documents/Org")
(setq org-agenda-files "~/Documents/Org/Agenda/org-agenda-files.txt")

(setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2 :fileskip0 t))
(setq org-agenda-tags-todo-honor-ignore-options t)
(setq org-agenda-todo-ignore-scheduled 'future)
(setq org-agenda-todo-ignore-deadlines 'far)
(setq org-agenda-todo-ignore-with-date 'future)
(setq org-agenda-todo-ignore-timestamp 'future)
(setq org-agenda-skip-deadline-prewarning-if-scheduled t)
(setq org-agenda-skip-timestamp-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-deadline-is-shown t)

(setq org-agenda-custom-commands
      '(("d" "Day Agenda" agenda ""
	 ((org-agenda-span 'day)
	  (org-agenda-tag-filter-preset '("-someday" "-inbox"))))
	("x" "E[x]tra tasks" tags-todo "-someday-inbox/TODO")
	("g" . "Getting Things Done")
	("gA" "Agenda minus recurring tasks"
	 agenda ""
	 ((org-agenda-tag-filter-preset '("-recurring"))))
	("gi" "Inbox" tags "inbox")
	("gs" "Someday"
	 ((todo "PROJ")
	  (tags-todo "-proj/TODO"))
	 ((org-agenda-tag-filter-preset '("+someday"))))
	("gc" "Review for Tasks Complete"
	 todo "TODO"
	 ((org-agenda-tag-filter-preset '("-someday" "-recurring" "-gtd"))))
	("gw" "Waiting tasks" todo "WAITING")
	("ga" "Archivable"
	 ((tags "-proj/DONE")
	  (tags "-proj/CANCELLED")))
	("gp" "Projects" tags-todo "-someday/PROJ")))

(setq org-default-notes-file
      (expand-file-name "Agenda/agenda.org" org-directory))

(setq org-capture-templates
      `(("d" "Do ASAP" entry (file "") "* TODO %?\nSCHEDULED: %t")
	("t" "TODO" entry (file "") "* TODO %? :inbox:")
	("l" "TODO with [l]ink" entry (file "") "* TODO %? :inbox:\ncf %a ")

	("w" "Weekly summary" plain
	 (file ,(format-time-string "weekly-summaries/%F.org"))
	 (file "weekly-summaries/template.org")
	 :immediate-finish t
         :jump-to-captured t)

	("b" "Things to Brag about!" entry
	 (file+olp+datetree "bragging.org")
	 "* %?"
	 :time-prompt t)

	("B" "Blog Post" plain
	 (function (lambda ()
		     (find-file (format "~/blog/content/posts/000-DRAFT-%#x.org"
					(time-convert nil 'integer)))))
	 (file "Templates/post.org"))

        ("r" "New GTD Review" plain
	 (file ,(format-time-string "GTD/%F.org"))
	 (file "GTD/review-template.org"))))

(org-babel-do-load-languages 'org-babel-load-languages
			     '((emacs-lisp . t)
			       (sql . t)
			       (shell . t)
			       (plantuml . t)))
#+end_src

* Org Roam
[[https://github.com/org-roam/org-roam][Org-roam]] is meant to be an "exo-brain", modelled after the Zettelkasten method. I like aspects of it, and especially excited about the simplification in v2.

This allows me to capture links to websites from my browser, and store it as a resource in Org roam.

#+begin_src emacs-lisp
(require 'org-roam)
(require 'org-roam-protocol)

(setq org-roam-directory (file-truename "~/Documents/Org"))
(setq org-roam-node-display-template
      (concat "${title:*} " (propertize "${tags:20}" 'face 'org-tag)))

(setq org-roam-capture-templates
      '(("d" "default" plain "%?" :target
	 (file+head "Roam/%<%Y%m%d%H%M%S>-${slug}.org"
		    "#+title: ${title}\n")
	 :unnarrowed t)))

(keymap-global-set "C-c n f" #'org-roam-node-find)
(keymap-global-set "C-c n r" #'org-roam-ref-add)

(keymap-set org-mode-map "C-c n i" #'org-roam-node-insert)
(keymap-set org-mode-map "C-c n t" #'org-roam-tag-add)

(add-hook 'after-init-hook #'org-roam-db-autosync-mode)

(defun sb/org-roam-node-random ()
  "Open a random Org Roam Node (ignoring Dailies)"
  (interactive)
  (org-roam-node-random nil
			(lambda (roam-node)
			  (not
			   (org-roam-dailies--daily-note-p
			    (org-roam-node-file roam-node))))))
#+end_src
* Org Present
#+begin_src emacs-lisp
(require 'org-present)
(require 'visual-fill-column)

(setq org-present-hide-stars-in-headings nil)

(defun sb/org-present-start ()
  (org-display-inline-images)
  (org-present-read-only)
  (org-present-hide-cursor)

  ;; Bigger fonts when presenting
  (setq-local face-remapping-alist
	      '((default (:height 1.5) variable-pitch)
                (header-line (:height 4.0) variable-pitch)
                (org-document-title (:height 1.75) org-document-title)
                (org-code (:height 1.55) org-code)
                (org-verbatim (:height 1.55) org-verbatim)
                (org-block (:height 1.4) org-block)
                (org-block-begin-line (:height 0.7) org-block)))

  (flyspell-mode 0)

  ;; Set a blank header line string to create blank space at the top
  (setq header-line-format " ")

  (setq-local org-hide-emphasis-markers t))

(defun sb/org-present-quit ()
  (org-remove-inline-images)
  (org-present-read-write)
  (org-present-show-cursor)

  ;; Reset text sizes
  (setq-local face-remapping-alist
	      '((default variable-pitch default)))

  ;; Clear the header line string so that it isn't displayed
  (setq header-line-format nil)

  (setq-local org-present-hide-stars-in-headings nil)
  (setq-local org-hide-emphasis-markers nil))

(add-hook 'org-present-mode-hook 'sb/org-present-start)
(add-hook 'org-present-mode-quit-hook 'sb/org-present-quit)
#+end_src
* Org Roam Dailies

I use org roam dailies for my daily notes. It integrates nicely with Roam, so I can "promote" notes from my daily files to my main Roam db.

#+begin_src emacs-lisp
(require 'org-roam-dailies)
(setq org-roam-dailies-directory "Daily/")
(keymap-global-set "C-c d" #'org-roam-dailies-map)
#+end_src

* Org Superstar Mode
#+begin_src emacs-lisp
(require 'org-superstar)
(add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
#+end_src
* Orgalist
Edit "Org-like" lists in non-Org buffers.
#+begin_src emacs-lisp
(require 'orgalist)
(add-hook 'message-mode-hook #'orgalist-mode)
#+end_src

* PlantUML

I sometimes need to draw UML diagrams, both on their own and embedded in Org documents.

#+begin_src emacs-lisp
(require 'plantuml-mode)
(require 'ob-plantuml)

(add-to-list 'auto-mode-alist '("\\.puml\\'" . plantuml-mode))

(setq plantuml-indent-level 4
      plantuml-default-exec-mode 'executable
      plantuml-font-lock-keywords t

      org-plantuml-exec-mode 'plantuml)

(defun sb/no-tabs-in-plantuml ()
  (setq indent-tabs-mode nil))

(add-hook 'plantuml-mode-hook #'sb/no-tabs-in-plantuml)
#+end_src

* Projectile

I use Projectile to navigate my projects. Some of the things I like about it are that it provides the following key bindings:

- =C-c p f= :: Find a file in this project.
- =C-c p k= :: Close all buffers for this project.
- =C-c p t= :: This switches from an implementation file to its test file,
               or vice versa. I use this extensively in Clojure mode. It
               might not make sense for all languages; YMMV.
- =C-c p s r= :: Ripgrep for something in this project. If point is at
                 a token, default to searching for that.

#+BEGIN_SRC emacs-lisp
(require 'projectile)

;; Register project type for non-standard Clojure projects with weird
;; test file names. Override the project type in .dir-locals.el.
(projectile-register-project-type 'lein-legacy '("project.clj" ".projectile-lein-legacy")
                                  :project-file "project.clj"
                                  :compile "lein compile"
                                  :test "lein test"
                                  :test-prefix "test_")

(keymap-global-set "C-c p" #'projectile-command-map)

(setq projectile-create-missing-test-files 'projectile-find-file
      projectile-project-search-path '("~/src")
      projectile-switch-project-action 'projectile-find-file)

;; Don't do projectile stuff on remote files
;; from https://github.com/syl20bnr/spacemacs/issues/11381#issuecomment-481239700
(defadvice projectile-project-root (around ignore-remote first activate)
  (unless (file-remote-p default-directory) ad-do-it))

(projectile-mode)
#+END_SRC

* Protobuf Mode
We use protobufs for service-to-service communication at work. Stolen from Robin Schroer.

#+BEGIN_SRC emacs-lisp
(require 'protobuf-mode)
(defun sulami/init-protobuf-imenu ()
  "Sets up imenu support for Protobuf.

Stolen from Spacemacs."
  (setq
   imenu-generic-expression
   '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2))))

(add-hook 'protobuf-mode-hook #'sulami/init-protobuf-imenu)
#+END_SRC

* Ripgrep

I have to delay the setup until after nix paths have loaded, otherwise ~executable-find~ can't find my ~rg~ executable.

I often look for stuff in "hidden" files like =circleci/config.yml=, yet I don't want hits stuff from my git history, so explicitly ignore that directory rather than all "hidden" files. ([[https://github.com/BurntSushi/ripgrep/issues/623#issuecomment-659909044][ref]])

#+begin_src emacs-lisp
(require 'rg)

(setq rg-command-line-flags '("--glob='!.git'"))

(rg-enable-default-bindings)
#+end_src

* Server Start

This is necessary for =emacsclient= and therefore =org-roam-protocol=.
#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+end_src
* SmartParens

Structural editing is a must when editing lisp, and it has bled into other aspects of programming for me. In particular the ability to remove surrounding parens / quotes with ~sp-unwrap-sexp~ is incredibly useful even in text mode.

#+BEGIN_SRC emacs-lisp
(require 'smartparens-config)

(add-hook 'text-mode-hook #'smartparens-mode)
(add-hook 'org-mode-hook #'smartparens-strict-mode)
(add-hook 'prog-mode-hook #'smartparens-strict-mode)
(add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
(add-hook 'minibuffer-setup-hook 'turn-on-smartparens-strict-mode)

(keymap-set smartparens-mode-map "C-M-f" 'sp-forward-sexp)
(keymap-set smartparens-mode-map "C-M-b" 'sp-backward-sexp)

(keymap-set smartparens-mode-map "C-M-u" 'sp-backward-up-sexp)
(keymap-set smartparens-mode-map "C-M-d" 'sp-down-sexp) ;; hijacked by macOS :-(

(keymap-set smartparens-mode-map "C-<right>" 'sp-forward-slurp-sexp)
(keymap-set smartparens-mode-map "C-<left>" 'sp-forward-barf-sexp)

(keymap-set smartparens-mode-map "C-M-<left>" 'sp-backward-slurp-sexp)
(keymap-set smartparens-mode-map "C-M-<right>" 'sp-backward-barf-sexp)

(keymap-set smartparens-mode-map "s-u" 'sp-unwrap-sexp)
(keymap-set smartparens-mode-map "C-M-<backspace>" 'sp-splice-sexp-killing-backward)

(keymap-set smartparens-mode-map "M-j" 'sp-join-sexp)

(keymap-set smartparens-mode-map "C-M-t" 'sp-transpose-sexp)
(keymap-set smartparens-mode-map "C-M-k" 'sp-kill-sexp)

(diminish 'smartparens-mode)
(diminish 'smartparens-strict-mode)
#+END_SRC

* String Inflection

Sometimes I need to swap between CamelCase and snake_case, or even SCREAMING_SNAKE_CASE.

#+begin_src emacs-lisp
(require 'string-inflection)
#+end_src

* Subword

Treats CapitalizedWords as separate, so we can move forward by their components. Useful in anything that looks like Java.

#+begin_src emacs-lisp
(require 'subword)
(add-hook 'prog-mode-hook #'subword-mode)
#+end_src

* Sudo-edit
Allows me to switch to root for editing a file. (Usually =/etc/hosts=.)
#+begin_src emacs-lisp
(require 'sudo-edit)
#+end_src
* Terraform Mode
#+begin_src emacs-lisp
(require 'terraform-mode)
#+end_src
* Verb

This is a package I use for interacting with REST HTTP APIs. Before arriving at it I tried restclient, walkman, and http.el. All have their strengths and weaknesses, but Verb seems the most well-rounded feature set. The hierachical inheritance is what really sold me, as it works really well with REST APIs to reduce boilerplate.

#+begin_src emacs-lisp
(require 'verb)
(with-eval-after-load "org"
  (keymap-set org-mode-map "C-c C-r" verb-command-map))

(defun sb/api-token-for-host (host)
  "Return a token for the specified host."
  (let ((found (nth 0 (auth-source-search :host host :create nil))))
    (when found
      (let ((secret (plist-get found :secret)))
	(if (functionp secret)
	    (funcall secret)
	  secret)))))
#+end_src

* Vertico: Vertical Selection (e.g. in minibuffer)
#+begin_src emacs-lisp
(require 'vertico)
(vertico-mode)
(setq vertico-resize t)
#+end_src
* Whitespace annoyances
Highlight certain whitespace annoyances, and clean them up automatically.

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(keymap-global-set "C-x w" #'whitespace-cleanup)
(global-whitespace-mode)

(diminish 'global-whitespace-mode)
#+END_SRC

* Winner Mode
Allow undoing changes to window layout. Keybindings:

- =C-c <left>= to undo
- =C-c <right>= to redo (while undoing)

#+begin_src emacs-lisp
(winner-mode)
#+end_src
* YAML
CircleCI and CloudFormation loves YAML.

#+BEGIN_SRC emacs-lisp
(require 'yaml-mode)
#+END_SRC
